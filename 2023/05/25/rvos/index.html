<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rvos | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="RVOS汇编器AS反汇编 1riscv64-unknown-elf-objdump -D -b binary -m riscv test.bin &gt; disassembly_out  1. 基础vim替换 12#全局替换整个文件中的 old 为 new%s&#x2F;old&#x2F;new&#x2F;g  1.1 GCC的使用1.2 GDB的使用1gdb -x .&#x2F;gdbinit  examine: inspect m">
<meta property="og:type" content="article">
<meta property="og:title" content="rvos">
<meta property="og:url" content="https://songyj123.github.io/2023/05/25/rvos/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RVOS汇编器AS反汇编 1riscv64-unknown-elf-objdump -D -b binary -m riscv test.bin &gt; disassembly_out  1. 基础vim替换 12#全局替换整个文件中的 old 为 new%s&#x2F;old&#x2F;new&#x2F;g  1.1 GCC的使用1.2 GDB的使用1gdb -x .&#x2F;gdbinit  examine: inspect m">
<meta property="og:locale">
<meta property="og:image" content="https://hackmd.io/_uploads/rkm6WamSh.png">
<meta property="og:image" content="https://hackmd.io/_uploads/By0TbTmBn.png">
<meta property="og:image" content="https://i.imgur.com/CDQdXyl.png">
<meta property="og:image" content="https://i.imgur.com/ITmIldM.png">
<meta property="og:image" content="https://hackmd.io/_uploads/Hy5wrdXE3.png">
<meta property="og:image" content="https://i.imgur.com/HeJ9s6n.png">
<meta property="og:image" content="https://i.imgur.com/NhynPMJ.png">
<meta property="og:image" content="https://i.imgur.com/wl3cr8p.png">
<meta property="og:image" content="https://i.imgur.com/melYd6o.png">
<meta property="og:image" content="https://i.imgur.com/WeIaEUv.png">
<meta property="og:image" content="https://i.imgur.com/zHz5zAD.png">
<meta property="og:image" content="https://i.imgur.com/DCh5WeF.png">
<meta property="og:image" content="https://i.imgur.com/L88wFbv.png">
<meta property="og:image" content="https://i.imgur.com/oPT8bHO.png">
<meta property="og:image" content="https://hackmd.io/_uploads/ryTx1cXV2.png">
<meta property="article:published_time" content="2023-05-25T13:41:54.000Z">
<meta property="article:modified_time" content="2023-05-25T13:44:16.449Z">
<meta property="article:author" content="SONGyj">
<meta property="article:tag" content="risc-v os">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hackmd.io/_uploads/rkm6WamSh.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://songyj123.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-rvos" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/25/rvos/" class="article-date">
  <time class="dt-published" datetime="2023-05-25T13:41:54.000Z" itemprop="datePublished">2023-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      rvos
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="RVOS"><a href="#RVOS" class="headerlink" title="RVOS"></a>RVOS</h1><p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/as/index.html">汇编器AS</a><br>反汇编</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-objdump -D -b binary -m riscv test.bin &gt; disassembly_out</span><br></pre></td></tr></table></figure>

<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>替换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局替换整个文件中的 old 为 new</span></span><br><span class="line">%s/old/new/g</span><br></pre></td></tr></table></figure>

<h2 id="1-1-GCC的使用"><a href="#1-1-GCC的使用" class="headerlink" title="1.1 GCC的使用"></a>1.1 GCC的使用</h2><h2 id="1-2-GDB的使用"><a href="#1-2-GDB的使用" class="headerlink" title="1.2 GDB的使用"></a>1.2 GDB的使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -x ./gdbinit</span><br></pre></td></tr></table></figure>

<p>examine: inspect memory contents</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/nfu addr</span><br></pre></td></tr></table></figure>

<p>n: count<br>f: format<br>u: unit size</p>
<p>只观察thread 1到达断点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> _start thread 1</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://doc.ecoscentric.com/gnutools/doc/gdb/Threads.html">Debug Multithread Program with GDB</a></p>
<p>在某个地址打断点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *0x80000000</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Makefile"><a href="#1-3-Makefile" class="headerlink" title="1.3 Makefile"></a>1.3 Makefile</h2><p>自动化变量 <strong>Automatic varibles</strong></p>
<ul>
<li>$@ 指代生成的目标文件 target filename</li>
<li>$&lt; 指代第一材料文件 1st prerequisit filename</li>
<li>$^ 指代所有的材料文件</li>
</ul>
<h2 id="1-4-Linkerscript"><a href="#1-4-Linkerscript" class="headerlink" title="1.4 Linkerscript"></a>1.4 Linkerscript</h2><p>链接的代码段最前面的一定要自己指定好<br>刚才重写了sbi的链接脚本 去掉了之前指定sbi_boot.s代码段在最前面的标号 直接所有用text表示结果gdb调试进不去 发现本来sbi_boot的代码段链接在sbi_main.c代码段后面去了</p>
<h3 id="1-4-1-ALIGN"><a href="#1-4-1-ALIGN" class="headerlink" title="1.4.1 ALIGN()"></a>1.4.1 ALIGN()</h3><h3 id="1-4-2-在源文件中使用链接脚本当中的变量"><a href="#1-4-2-在源文件中使用链接脚本当中的变量" class="headerlink" title="1.4.2 在源文件中使用链接脚本当中的变量"></a>1.4.2 在源文件中使用链接脚本当中的变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_s_text = 0x80000000;</span><br></pre></td></tr></table></figure>

<p>在c源文件中访问 <strong>_s_text</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> _s_text;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *value_in_var;</span><br><span class="line">value_in_var = &amp;_s_text;</span><br></pre></td></tr></table></figure>

<p>可以将这个特殊的变量 <strong>_s_text</strong> 看成是一个空值的变量，他在symbol table上的对应的地址是0x80000000<br>我们访问一个变量的地址用&amp;<br><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Source-Code-Reference.html">参考</a></p>
<h2 id="1-5-汇编和C"><a href="#1-5-汇编和C" class="headerlink" title="1.5 汇编和C"></a>1.5 汇编和C</h2><h3 id="1-5-1-汇编"><a href="#1-5-1-汇编" class="headerlink" title="1.5.1 汇编"></a>1.5.1 汇编</h3><h4 id="大端小端-big-endian-x2F-little-endian-讲的是字节不是位"><a href="#大端小端-big-endian-x2F-little-endian-讲的是字节不是位" class="headerlink" title="大端小端 big endian&#x2F;little endian 讲的是字节不是位"></a>大端小端 big endian&#x2F;little endian 讲的是字节不是位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">128 64 32 16 8 4 2 1 is big endian，big-end comes first</span><br><span class="line">1 2 4 8 16 32 64 128 is little endian，little-end comes first 低位字节在前面</span><br></pre></td></tr></table></figure>

<h4 id="字节对齐-align"><a href="#字节对齐-align" class="headerlink" title="字节对齐 align"></a>字节对齐 align</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//字节对齐</span><br><span class="line">.align size-log-2</span><br></pre></td></tr></table></figure>

<h4 id="存储指令"><a href="#存储指令" class="headerlink" title="存储指令"></a>存储指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#存储指令</span><br><span class="line">#sd rs1, offset(rs2)</span><br><span class="line">#往0x80000000上写0</span><br><span class="line">li a0, 0x80000000</span><br><span class="line">sd zero, (a0)</span><br></pre></td></tr></table></figure>

<h4 id="call-j-jr"><a href="#call-j-jr" class="headerlink" title="call j jr"></a>call j jr</h4><p>call和j指令需要特别注意，call是一条伪指令相当于把pc+4放入ra</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#函数调用指令 call</span><br><span class="line">call add_ab</span><br><span class="line">#等价于</span><br><span class="line">#ra &lt;-- pc+4</span><br><span class="line">#j add_ab</span><br><span class="line"></span><br><span class="line">#函数返回指令 ret</span><br><span class="line">ret</span><br><span class="line">#等价于</span><br><span class="line">#pc &lt;-- ra</span><br></pre></td></tr></table></figure>

<p><strong>jr</strong>用于跳转寄存器里面存的地址</p>
<h4 id="AUIPC-LUI"><a href="#AUIPC-LUI" class="headerlink" title="AUIPC LUI"></a>AUIPC LUI</h4><p>Add Upper Immediate to Program Counter<br>Load Upper Immediate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将立即数带符号左移12bits加到PC</span><br><span class="line">auipc a5, 0x02</span><br><span class="line">#将立即数带符号左移12bits</span><br><span class="line">lui a5, 0x02</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-C语法"><a href="#1-5-1-C语法" class="headerlink" title="1.5.1 C语法"></a>1.5.1 C语法</h3><p>函数指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func_ptr_name是一个指向函数的指针，这个函数有两个int参数，返回的值是int</span></span><br><span class="line"><span class="built_in">int</span> (*func_ptr_name)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cast</span></span><br><span class="line"><span class="comment">//some_ptr是一个函数指针</span></span><br><span class="line">(<span class="built_in">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>))some_ptr;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数指针数组</span></span><br><span class="line"><span class="comment">//类似[SYS_fork]是索引</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">syscalls[num]();</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-riscv的寄存器"><a href="#1-5-1-riscv的寄存器" class="headerlink" title="1.5.1 riscv的寄存器"></a>1.5.1 riscv的寄存器</h3><h4 id="General-reg"><a href="#General-reg" class="headerlink" title="General reg"></a>General reg</h4><p>通用寄存器有别名和特殊用途</p>
<table>
<thead>
<tr>
<th>通用寄存器</th>
<th>别名</th>
<th>特殊用途</th>
</tr>
</thead>
<tbody><tr>
<td>x0</td>
<td>zero</td>
<td><strong>全零寄存器</strong></td>
</tr>
<tr>
<td>x1</td>
<td>ra</td>
<td><strong>函数返回地址</strong></td>
</tr>
<tr>
<td>x2</td>
<td>sp</td>
<td><strong>stack ptr</strong></td>
</tr>
<tr>
<td>x3</td>
<td>gp</td>
<td><strong>globle ptr</strong></td>
</tr>
<tr>
<td>x5<del>x7, x28</del>x31</td>
<td>t0<del>t2, t3</del>t6</td>
<td><strong>tempories</strong> Callee可能会使用不保证在函数调用过程中不变</td>
</tr>
<tr>
<td>x8<del>x9, x18</del>x27</td>
<td>s0<del>s1, s2</del>s11</td>
<td><strong>saved</strong> Callee如果要使用必须在stack中备份，退出时恢复</td>
</tr>
<tr>
<td>x10~x11</td>
<td>a0~a1</td>
<td><strong>argument</strong> 参数寄存器 函数返回值也在里面</td>
</tr>
<tr>
<td>x12~x17</td>
<td>a2~a7</td>
<td><strong>argument</strong> 参数寄存器</td>
</tr>
</tbody></table>
<h4 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h4><table>
<thead>
<tr>
<th>CSR</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>msratch</td>
<td>m模式下上下文数据指针</td>
</tr>
<tr>
<td>mcause</td>
<td>m模式异常中断</td>
</tr>
<tr>
<td>satp</td>
<td>s模式页表指针</td>
</tr>
<tr>
<td>scause</td>
<td>s模式异常中断</td>
</tr>
<tr>
<td>sepc</td>
<td>s模式异常中断处理之后返回的地址</td>
</tr>
<tr>
<td>stvec</td>
<td>s模式异常中断进入的地址</td>
</tr>
</tbody></table>
<h4 id="Stack-versus-Heap"><a href="#Stack-versus-Heap" class="headerlink" title="Stack versus Heap"></a>Stack versus Heap</h4><p>都存在于RAM当中</p>
<p>每一个线程都有自己的stack 所有的线程共享同一个heap</p>
<p>stack是确定的长度不能改变 heap的长度可以改变 如果需要heap存一个新的变量但是没有足够的空间 操作系统可以分配新的空间给到heap</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Statically allocated in the data segment when the program/DLL is first loaded</span></span><br><span class="line"><span class="comment">// Deallocated when the program/DLL exits</span></span><br><span class="line"><span class="comment">// scope - can be accessed from anywhere in the code</span></span><br><span class="line"><span class="type">int</span> someGlobalVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Statically allocated in the data segment when the program is first loaded</span></span><br><span class="line"><span class="comment">// Deallocated when the program/DLL exits</span></span><br><span class="line"><span class="comment">// scope - can be accessed from anywhere in this particular code file</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> someStaticVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;someArgument&quot; is allocated on the stack each time MyFunction is called</span></span><br><span class="line"><span class="comment">// &quot;someArgument&quot; is deallocated when MyFunction returns</span></span><br><span class="line"><span class="comment">// scope - can be accessed only within MyFunction()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">(<span class="type">int</span> someArgument)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Statically allocated in the data segment when the program is first loaded</span></span><br><span class="line">    <span class="comment">// Deallocated when the program/DLL exits</span></span><br><span class="line">    <span class="comment">// scope - can be accessed only within MyFunction()</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> someLocalStaticVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocated on the stack each time MyFunction is called</span></span><br><span class="line">    <span class="comment">// Deallocated when MyFunction returns</span></span><br><span class="line">    <span class="comment">// scope - can be accessed only within MyFunction()</span></span><br><span class="line">    <span class="type">int</span> someLocalVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A *pointer* is allocated on the stack each time MyFunction is called</span></span><br><span class="line">    <span class="comment">// This pointer is deallocated when MyFunction returns</span></span><br><span class="line">    <span class="comment">// scope - the pointer can be accessed only within MyFunction()</span></span><br><span class="line">    <span class="type">int</span>* someDynamicVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This line causes space for an integer to be allocated in the heap</span></span><br><span class="line">    <span class="comment">// when this line is executed. Note this is not at the beginning of</span></span><br><span class="line">    <span class="comment">// the call to MyFunction(), like the automatic variables</span></span><br><span class="line">    <span class="comment">// scope - only code within MyFunction() can access this space</span></span><br><span class="line">    <span class="comment">// *through this particular variable*.</span></span><br><span class="line">    <span class="comment">// However, if you pass the address somewhere else, that code</span></span><br><span class="line">    <span class="comment">// can access it too</span></span><br><span class="line">    someDynamicVariable = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This line deallocates the space for the integer in the heap.</span></span><br><span class="line">    <span class="comment">// If we did not write it, the memory would be &quot;leaked&quot;.</span></span><br><span class="line">    <span class="comment">// Note a fundamental difference between the stack and heap</span></span><br><span class="line">    <span class="comment">// the heap must be managed. The stack is managed for us.</span></span><br><span class="line">    <span class="keyword">delete</span> someDynamicVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In other cases, instead of deallocating this heap space you</span></span><br><span class="line">    <span class="comment">// might store the address somewhere more permanent to use later.</span></span><br><span class="line">    <span class="comment">// Some languages even take care of deallocation for you... but</span></span><br><span class="line">    <span class="comment">// always it needs to be taken care of at runtime by some mechanism.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the function returns, someArgument, someLocalVariable</span></span><br><span class="line">    <span class="comment">// and the pointer someDynamicVariable are deallocated.</span></span><br><span class="line">    <span class="comment">// The space pointed to by someDynamicVariable was already</span></span><br><span class="line">    <span class="comment">// deallocated prior to returning.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that someGlobalVariable, someStaticVariable and</span></span><br><span class="line"><span class="comment">// someLocalStaticVariable continue to exist, and are not</span></span><br><span class="line"><span class="comment">// deallocated until the program exits.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="stack-trace-栈回溯"><a href="#stack-trace-栈回溯" class="headerlink" title="stack trace(栈回溯)"></a>stack trace(栈回溯)</h5><p>当我们出现异常时，os通常可以打印出一系列函数调用的信息，这是怎么做到的？</p>
<p>编译器使能frame pointer之后(-fno-omit-frame-pointer)，每次进入函数会有如下汇编代码生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#stack腾出16byte的空间</span><br><span class="line">#先放函数返回地址ra（8byte），再放fp（8byte）</span><br><span class="line">#此时的fp存储的是上一个函数分配的stack空间的起始地址</span><br><span class="line">#更新fp=当前函数被分配的stack空间起始地址</span><br><span class="line">addi sp, sp, -16</span><br><span class="line">sd ra, 8(sp)</span><br><span class="line">sd fp, 0(sp)</span><br><span class="line">addi fp, sp, 16</span><br></pre></td></tr></table></figure>

<p>stack是从高地址向低地址生长，所以在用指针去访问存储在stack当中的结构体时要注意</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将上述fp和ra看成一个结构体</span></span><br><span class="line"><span class="comment">//因为stack和地址是反的 从地址的角度来看低地址放的是fp高地址放的是ra</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stack_frame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sf_fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sf_ra;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">back_trace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//取得当前的fp值</span></span><br><span class="line">    <span class="comment">//__builtin_frame_address gcc自带特性</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cur_fp = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过结构体指针去访问stack frame</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stack_frame</span> *sf_ptr = cur_fp - <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环条件在代码段中</span></span><br><span class="line">    <span class="keyword">while</span>(sf_ptr-&gt;sf_fp &gt; &amp;_stext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回地址减去4就是程序的调用地址</span></span><br><span class="line">        pc = sf_ptr-&gt;sf_ra - <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pc: %p\n&quot;</span>, pc);</span><br><span class="line">        <span class="comment">//指向下一个stack frame</span></span><br><span class="line">        sf_ptr = sf_ptr-&gt;sf_fp - <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-static-inline"><a href="#1-5-2-static-inline" class="headerlink" title="1.5.2 static inline"></a>1.5.2 static inline</h3><p>在异常处理或者中断的时候经常见到调用一个函数然后然后找到这个函数发现他是**static inline …**里面只有一条汇编指令 感觉有点看不懂</p>
<p><strong>inline关键字什么意思？</strong><br>函数定义前面加inline表示这是一个Inline Function Inline Function are those function whose definitions are small and be substituted at the place where its function call is happened.<br>这种函数一般很短，转换成汇编指令可能只有一条指令。如果将它写成一个普通的函数跳转过去执行 可能跳转执行然后再返回的一串指令比这条指令本身长很多，这样执行效率会降低。</p>
<p><strong>inline</strong>提示编译器可以把这条内联函数直接编译到调用他的代码出处，这样无需跳转返回的一系列指令 但是这也只是一条hint 编译器不一定会inline这个函数</p>
<p><strong>为什么要前面加上static呢?</strong><br>如果只有前面的inline对于GCC来说会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add_two</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">add_two</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;output : %d&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /tmp/ccy8plLQ.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">try_inline.c:(.text+0x17): undefined reference to `add_two&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>

<p>前面说到inline只是一条建议 建议编译器可以内联 但是编译器不一定会采纳<br>所以这里实际的意思是告诉编译器<strong>This is an alternative function to use if you want to inline this function</strong></p>
<p>在rk3399中读取pc寄存器的值只使用static inline并没有内联还是跳转到了函数的位置：<br><img src="https://hackmd.io/_uploads/rkm6WamSh.png"></p>
<p>内联汇编之后之前的r_pc()函数就消失了，所以程序的地址也发生了改变：</p>
<p><img src="https://hackmd.io/_uploads/By0TbTmBn.png"></p>
<p>加上static则可以避免这个错误，让编译器把这个函数当作internal linkage</p>
<blockquote>
<p>If you don’t put <strong>static</strong> there, you’re defining an inline function with external linkage without instantiating an external definition.</p>
</blockquote>
<p><strong>如何强制inline一个函数呢？</strong></p>
<p>GCC提供了<strong>attribute((always_inline))</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __attribute__((always_inline)) <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">r_pc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="string">&quot;adr %0, .&quot;</span></span></span><br><span class="line"><span class="params">			: <span class="string">&quot;=r&quot;</span> (x)</span></span><br><span class="line"><span class="params">			:</span></span><br><span class="line"><span class="params">			:</span></span><br><span class="line"><span class="params">				)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Inline.html">gcc&#x2F;Inline</a></p>
<h3 id="1-5-3-UART输出字符串的写法对比"><a href="#1-5-3-UART输出字符串的写法对比" class="headerlink" title="1.5.3 UART输出字符串的写法对比"></a>1.5.3 UART输出字符串的写法对比</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uart_send_string</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *string_ptr = str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*string_ptr != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">uart_send_char</span>(*string_ptr);</span><br><span class="line">    string_ptr++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">    <span class="built_in">uart_putc</span>(*s++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到 <strong>i++</strong> <strong>++i</strong> 的区别<br>i++先返回值后inc<br>++i先inc后返回值<br><strong>++i</strong>是加一之后的值 <strong>i++</strong> 是加一之前的值</p>
<h3 id="1-5-4-printf的实现"><a href="#1-5-4-printf的实现" class="headerlink" title="1.5.4 printf的实现"></a>1.5.4 printf的实现</h3><p>实现完串口的输出，发现rvos和xv6都还实现了printf函数，这个看起来好像比较简单先实现一下这个文件</p>
<h4 id="可变参数函数-variadic-function-in-c"><a href="#可变参数函数-variadic-function-in-c" class="headerlink" title="可变参数函数 (variadic function in c)"></a>可变参数函数 (variadic function in c)</h4><p>此处涉及到的宏定义暂不深究<br>va_list<br>va_start()<br>va_arg()<br>va_end()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...表示数量不定的参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, format);    <span class="comment">//va_start的第二个参数是...之前的参数，即最后一个确定的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; *format!=<span class="number">0</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//va_arg()执行一次会返回一个参数值，然后指到下一个参数</span></span><br><span class="line">        <span class="comment">//解析格式字符串的%标记以及后面的字符来确定打印类型</span></span><br><span class="line">        <span class="keyword">if</span>(*fmt == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(*(++fmt))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">va_arg</span>(args, 可变参数类型（<span class="type">int</span>，<span class="type">char</span>，<span class="type">float</span> ...）);</span><br><span class="line">                    <span class="comment">//分别根据单独的数据类型输出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">va_arg</span>(args, 可变参数类型（<span class="type">int</span>，<span class="type">char</span>，<span class="type">float</span> ...）);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">va_arg</span>(args, 可变参数类型（<span class="type">int</span>，<span class="type">char</span>，<span class="type">float</span> ...）);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>：</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//处理特殊情况</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//指向下一个字符</span></span><br><span class="line">                format++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">uart_send_char</span>(*format++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-5-杂"><a href="#1-5-5-杂" class="headerlink" title="1.5.5 杂"></a>1.5.5 杂</h3><h4 id="固定串口设备的串口号并设置权限"><a href="#固定串口设备的串口号并设置权限" class="headerlink" title="固定串口设备的串口号并设置权限"></a>固定串口设备的串口号并设置权限</h4><p>每次sudo chmod太麻烦，用udev规则自动完成设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsusb 查看usb设备信息</span><br><span class="line">sudo vim /etc/udev/rules.d/99-serial-ports.rules <span class="comment">#设置udev规则表 默认两位数字开头 越小优先级越高</span></span><br><span class="line">添加 SUBSYSTEM==<span class="string">&quot;tty&quot;</span>, ATTRS&#123;idVendor&#125;==<span class="string">&quot;xxxx&quot;</span>, ATTRS&#123;idProduct&#125;==<span class="string">&quot;yyyy&quot;</span>, MODE=<span class="string">&quot;0666&quot;</span></span><br><span class="line">sudo udevadm control --reload-rules</span><br></pre></td></tr></table></figure>

<h1 id="2-Trap（异常的处理）"><a href="#2-Trap（异常的处理）" class="headerlink" title="2. Trap（异常的处理）"></a>2. Trap（异常的处理）</h1><p>调riscv板子的时候经常看到opensbi，但是又不知道opensbi干嘛的。只知道opensbi引导uboot，uboot再引导内核</p>
<h3 id="2-1-sbi服务"><a href="#2-1-sbi服务" class="headerlink" title="2.1 sbi服务"></a>2.1 sbi服务</h3><p>为运行在S模式的操作系统提供特权服务接口，sbi固件是运行在M模式的权限最高。<br>为处于低级别的程序提供访问重要硬件的接口</p>
<ul>
<li><input disabled="" type="checkbox"> 架构图</li>
</ul>
<h3 id="2-2-sbi系统调用是异常的一种"><a href="#2-2-sbi系统调用是异常的一种" class="headerlink" title="2.2 sbi系统调用是异常的一种"></a>2.2 sbi系统调用是异常的一种</h3><p>mcause寄存器有两个字段分别表示异常类型和中断类型</p>
<table>
<thead>
<tr>
<th>Interrupt</th>
<th>Exception Code</th>
</tr>
</thead>
<tbody><tr>
<td>1表示中断 0表示异常</td>
<td>具体的中断或者异常类型</td>
</tr>
</tbody></table>
<p>其中9号异常表示来自S模式的系统调用，通俗来说就是运行在S模式的操作系统通过上边提到的sbi服务接口完成了一些只能在M模式下面做的事情。</p>
<p>我们只需要顺清楚这里面的一种服务就可以知道他整个机制是如何运行的。</p>
<h3 id="2-3-异常过程（sbi系统调用为例）"><a href="#2-3-异常过程（sbi系统调用为例）" class="headerlink" title="2.3 异常过程（sbi系统调用为例）"></a>2.3 异常过程（sbi系统调用为例）</h3><p>sbi服务是软件产生的异常，那么如何产生呢？</p>
<h4 id="2-3-1-ECALL指令"><a href="#2-3-1-ECALL指令" class="headerlink" title="2.3.1 ECALL指令"></a>2.3.1 ECALL指令</h4><p>a0~a5存放形参 a7存放系统调用号，区分是哪个Syscall</p>
<p>ecall会提升特权模式 在s mode下使用会提升到m mode 并且PC跳转到mtvec指向的地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_CALL(which, arg0, arg1, arg2) (&#123;      \</span></span><br><span class="line"><span class="meta">  register unsigned long a0 asm (<span class="string">&quot;a0&quot;</span>) = (unsigned long)(arg0); \</span></span><br><span class="line"><span class="meta">  register unsigned long a1 asm (<span class="string">&quot;a1&quot;</span>) = (unsigned long)(arg1); \</span></span><br><span class="line"><span class="meta">  register unsigned long a2 asm (<span class="string">&quot;a2&quot;</span>) = (unsigned long)(arg2); \</span></span><br><span class="line"><span class="meta">  register unsigned long a7 asm (<span class="string">&quot;a7&quot;</span>) = (unsigned long)(which);  \</span></span><br><span class="line"><span class="meta">  asm volatile (<span class="string">&quot;ecall&quot;</span>         \</span></span><br><span class="line"><span class="meta">          : <span class="string">&quot;+r&quot;</span> (a0)       \</span></span><br><span class="line"><span class="meta">          : <span class="string">&quot;r&quot;</span> (a1), <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a7)    \</span></span><br><span class="line"><span class="meta">          : <span class="string">&quot;memory&quot;</span>);        \</span></span><br><span class="line"><span class="meta">  a0;             \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>在调用之前首先需要在sbi程序中设置好跳转地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbi_trap_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">w_mtvec</span>(sbi_exception_vec);</span><br><span class="line">  <span class="built_in">w_mie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据sbi_trap_init()代码，程序在执行ecall之后会跳转到sbi_exception_vec()这个函数这里，这是一个统一的入口函数，微机原理里面就学过，进入中断需要保存现场，这里ecall跳转的sbi_exception_vec()函数其实就算是中断处理函数。</p>
<ol>
<li>保存上下文(context)</li>
<li>切换sp</li>
<li>根据具体的系统调用功能执行相应的函数</li>
<li>恢复上下文</li>
<li>切换sp</li>
<li>根据mepc返回继续执行</li>
</ol>
<h4 id="2-3-2-USER模式下系统调用流程示意图"><a href="#2-3-2-USER模式下系统调用流程示意图" class="headerlink" title="2.3.2 USER模式下系统调用流程示意图"></a>2.3.2 USER模式下系统调用流程示意图</h4><p><img src="https://i.imgur.com/CDQdXyl.png"></p>
<h4 id="2-3-3-系统调用中传递参数"><a href="#2-3-3-系统调用中传递参数" class="headerlink" title="2.3.3 系统调用中传递参数"></a>2.3.3 系统调用中传递参数</h4><ul>
<li><input disabled="" type="checkbox"> kernel调用sbi的服务 kernel中使用ecall</li>
</ul>
<p>有的系统调用有参数，比如最简单的sleep(),sleep()的参数是休眠的时钟周期比如sleep(1000)，那在用户空间里面使用的参数怎么样传递到内核中去的呢？</p>
<p>根据riscv的函数调用标准，参数是存放在a0～a7当中的，这里sleep的参数休眠周期就会存放在a0中，回顾ecall指令发生时，第一步保存上下文将所有的寄存器全部放在trapframe当中，所以当执行到具体的syscall函数时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">argraw(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys_sleep()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> time_interval;</span><br><span class="line">    ...</span><br><span class="line">    time_interval = argraw(n);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然sys_sleep()本身没有参数，但是函数在一开始就通过读取trapframe的方式，获得了用户空间中的参数。</p>
<h3 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h3><p>在调试s模式的异常时，写好了s模式下的中断处理函数但是没有trap到s模式的中断处理函数，直接到了m模式的中断处理函数。重新看书才发现：</p>
<blockquote>
<p>委托异常与中断：<br>中断和异常触发之后默认M模式下进行处理，我们通常吧常用的异常和中断委托给S模式，这样才会跳转到S模式的异常向量表中去。</p>
</blockquote>
<h3 id="xv6中断过程"><a href="#xv6中断过程" class="headerlink" title="xv6中断过程"></a>xv6中断过程</h3><p>timervec<br>1.在CMP填入新值<br>2.置位SSIP</p>
<h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><p>软件中断 定时器中断 外部中断 调试中断</p>
<p>0x0d号中断 一般都是页表映射没设置好 导致找不到页面</p>
<h3 id="2-5-trapframe-trampoline"><a href="#2-5-trapframe-trampoline" class="headerlink" title="2.5 trapframe trampoline"></a>2.5 trapframe trampoline</h3><p>swtch保存上下文和uservec保存上下文为什么不一样？<br>swtch只保存了ra sp + s系列寄存器<br>uservec保存了所有</p>
<p><strong>trapframe</strong>用于保存用户进程的上下文，kernel进程的上下文则在自己的stack中保存，所以kernel进程是没有<strong>trapframe</strong>的。</p>
<h3 id="2-6-xv6-roadmap"><a href="#2-6-xv6-roadmap" class="headerlink" title="2.6 xv6 roadmap"></a>2.6 xv6 roadmap</h3><p><img src="https://i.imgur.com/ITmIldM.png" alt="xv6 roadmap"></p>
<h3 id="2-7-sleep-和wakeup"><a href="#2-7-sleep-和wakeup" class="headerlink" title="2.7 sleep()和wakeup()"></a>2.7 sleep()和wakeup()</h3><h3 id="2-8-问题记录"><a href="#2-8-问题记录" class="headerlink" title="2.8 问题记录"></a>2.8 问题记录</h3><ol>
<li>在测试串口中断时，串口中断标志位清除不了<br>最开始没有加入串口接收终端，但是但后期发现必须要有一个shell来执行命令才能运行更多的user程序测试多进程的一些东西。最后突然发现是没有读取接收数据缓存寄存器。。。</li>
</ol>
<h1 id="3-Page-Table"><a href="#3-Page-Table" class="headerlink" title="3. Page Table"></a>3. Page Table</h1><h2 id="3-1-为什么要有虚拟地址？"><a href="#3-1-为什么要有虚拟地址？" class="headerlink" title="3.1 为什么要有虚拟地址？"></a>3.1 为什么要有虚拟地址？</h2><p>试想有个一64K大小的程序需要运行在ram只有32K大小的电脑中，ram没有办法装入整个程序，我们应当如何让这个程序跑起来？<br>程序当中的内容不是所有的都对当前程序的正常运作有关系，我们可以将程序分成固定大小的page例如4K，那么64K程序可以分成16个page，分别标号0到15。同样的，我们将ram也分成4k大小的page并称为page frame，得到page frame 0～7。按照程序的需求将page和page frame对应起来，将需要用的page和page frame对应起来，即把需要的page里面的内容加载到对应的page frame处。</p>
<p>这样程序就跑起来了。但是64K大小的程序实际上只有32K的内容被加载到RAM当中，万一运行到没有加载的page的指令怎么办？此时这条指令的地址（虚拟地址）被传到MMU，MMU通过page号段查找到对应的PTE，发现根据PTE标志位段显示，这个地址所处的page没有被映射到page frame，触发page fault异常，异常处理会取消一对对应关系，重新将这个page映射一个page frame上，退出异常后再次寻址可以继续执行。</p>
<h2 id="3-2-虚拟地址组成"><a href="#3-2-虚拟地址组成" class="headerlink" title="3.2 虚拟地址组成"></a>3.2 虚拟地址组成</h2><p><strong>sv39分页机制</strong></p>
<table>
<thead>
<tr>
<th>最高25bits保留</th>
<th>27bits</th>
<th>12bits</th>
</tr>
</thead>
<tbody><tr>
<td><strong>保留</strong></td>
<td>page号</td>
<td>offset</td>
</tr>
</tbody></table>
<p><strong>12位的offset</strong>用于寻址<strong>4K</strong>的地址<br><strong>27位page号n</strong>说明这个地址位于<strong>第n个page</strong>，同时page table的 <strong>第n条目(PTE)</strong> 存储了page n的映射关系</p>
<p><strong>PTE (page table entry)</strong> </p>
<table>
<thead>
<tr>
<th>PPN (physical page number) page frame号</th>
<th>标志位 (eg.映射没映射)</th>
</tr>
</thead>
<tbody><tr>
<td>44bits</td>
<td>10bits</td>
</tr>
</tbody></table>
<p>44bits的page frame和12bits的offset可以在RAM上寻址。</p>
<h2 id="3-3-多级页表"><a href="#3-3-多级页表" class="headerlink" title="3.3 多级页表"></a>3.3 多级页表</h2><p>按照4k的分页方法，32位机器：</p>
<blockquote>
<p>2^32 &#x2F;4&#x2F;1024&#x3D;2^20&#x3D;1048576</p>
</blockquote>
<p>我们需要有1048576条PTE，这么大的页表放在RAM中是不可接受的，64位更多。</p>
<h2 id="3-4-TLB-Translation-Lookaside-Buffers"><a href="#3-4-TLB-Translation-Lookaside-Buffers" class="headerlink" title="3.4 TLB(Translation Lookaside Buffers)"></a>3.4 TLB(Translation Lookaside Buffers)</h2><blockquote>
<p>Most programs tend to make a large number of references to a small number of pages, and not the other way around.</p>
</blockquote>
<h2 id="3-5-页表创建流程"><a href="#3-5-页表创建流程" class="headerlink" title="3.5 页表创建流程"></a>3.5 页表创建流程</h2><p><img src="https://hackmd.io/_uploads/Hy5wrdXE3.png"></p>
<ol>
<li>分配4K空间，用于存放pagetable<br>4096byte&#x2F;8byte&#x3D;512 有512条PTE<br>在linker.ld当中给pagetable直接分配4k空间，放在数据段最后面。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">_sdata = .;</span><br><span class="line">.data :</span><br><span class="line">&#123;</span><br><span class="line">    *(.data)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(4096);</span><br><span class="line">_pgt_start = .;</span><br><span class="line">. += 4096;</span><br><span class="line">_edata = .;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义pgt_t是指向unsigned int的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> *<span class="type">pgt_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">pte_t</span>;</span><br></pre></td></tr></table></figure>

<p>PTE是最末一级页表的一个条目，这些页表都可以看作是一个数组，每个pte都是一个元素：<br><strong>unsigned long pagetable[512];</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//walk函数返回指向具体页表项(PTE)的指针</span></span><br><span class="line"><span class="comment">//walk函数可以让我们走到最末尾的元素上去</span></span><br><span class="line"><span class="function"><span class="type">pte_t</span> *<span class="title">walk</span><span class="params">(<span class="type">pgt_t</span> pagetable, <span class="type">unsigned</span> <span class="type">long</span> va, <span class="type">int</span> alloc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一开始我们只有虚拟地址假设是0x80200000以及一个根页表也就是上面linkerscript中分配的空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern unsigned long _pgt_start[];</span><br><span class="line">pgt_t pagetable = _pgt_start[];</span><br><span class="line">unsigned long va = 0x80200000;</span><br><span class="line"></span><br><span class="line">pte_t *walk(pagetable, va, 1);</span><br></pre></td></tr></table></figure>

<p><strong>虚拟地址示意:</strong></p>
<table>
<thead>
<tr>
<th>最高25bits保留</th>
<th>9bits</th>
<th>9bits</th>
<th>9bits</th>
<th>12bits</th>
</tr>
</thead>
<tbody><tr>
<td><strong>保留</strong></td>
<td>2级</td>
<td>1级</td>
<td>0级</td>
<td>offset</td>
</tr>
</tbody></table>
<p>根据2级目录寻找1级目录的位置，根据1级目录寻找0级目录的位置，而0级目录里面存放的就是我们真正的PTE</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="number">9b</span>its = va&gt;&gt;<span class="number">12</span>&gt;&gt;(<span class="number">9</span>*level) &amp; <span class="number">0x1FF</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//marco</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MASK 0x1FF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_NINE_BITS(va, level) ((va&gt;&gt;OFFSET&gt;&gt;(9*level)) &amp; MASK)</span></span><br></pre></td></tr></table></figure>

<p>若只考虑页表已经建立好，我们只来寻找最末PTE：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pte_t</span> *<span class="title">walk</span><span class="params">(<span class="type">pgt_t</span> pagetable, <span class="type">unsigned</span> <span class="type">long</span> va, <span class="type">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pgt_t</span> pgt_ptr;</span><br><span class="line">    pte *pte_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> level=<span class="number">2</span>; level&gt;<span class="number">0</span>; level--)</span><br><span class="line">    &#123;</span><br><span class="line">        pgt_ptr = &amp;pagetable[<span class="built_in">GET_NINE_BITS</span>(va, level)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个条目是valid</span></span><br><span class="line">        <span class="keyword">if</span>(*pgt_ptr | PG_V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取出存放的物理页号PPN 无符号右移10位 最末10位是flags</span></span><br><span class="line">            <span class="comment">//根据PPN得到下一个页表的首地址 左移12位</span></span><br><span class="line">            pgt_ptr = ((<span class="type">unsigned</span> <span class="type">long</span>)(*pgt_ptr))&gt;&gt;<span class="number">10</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pte_ptr = &amp;pagetable[<span class="built_in">GET_NINE_BITS</span>(va, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pte_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入页表没有建立好的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pte_t</span> *<span class="title">walk</span><span class="params">(<span class="type">pgt_t</span> pagetable, <span class="type">unsigned</span> <span class="type">long</span> va, <span class="type">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pgt_t</span> pgt_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> level=<span class="number">2</span>; level&gt;<span class="number">0</span>; level--)</span><br><span class="line">    &#123;</span><br><span class="line">        pgt_ptr = &amp;pagetable[<span class="built_in">GET_NINE_BITS</span>(va, level)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个条目是valid</span></span><br><span class="line">        <span class="keyword">if</span>(*pgt_ptr | PTE_V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取出存放的物理页号PPN 无符号右移10位 最末10位是flags</span></span><br><span class="line">            <span class="comment">//根据PPN得到下一个页表的首地址 左移12位</span></span><br><span class="line">            pagetable = ((<span class="type">unsigned</span> <span class="type">long</span>)(*pgt_ptr))&gt;&gt;<span class="number">10</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个条目不存在</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//允许分配且有内存可分配</span></span><br><span class="line">            <span class="keyword">if</span>(alloc || (pagetable=<span class="built_in">kalloc</span>())==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line">                <span class="comment">//回填</span></span><br><span class="line">                *pte_ptr = (((<span class="type">unsigned</span> <span class="type">long</span>)pagetable)&gt;&gt;<span class="number">12</span>&lt;&lt;<span class="number">10</span>) | PTE_V;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pte_ptr = &amp;pagetable[<span class="built_in">GET_NINE_BITS</span>(va, <span class="number">0</span>)];</span><br><span class="line">    <span class="keyword">return</span> pte_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-进程的Pagetable"><a href="#3-6-进程的Pagetable" class="headerlink" title="3.6 进程的Pagetable"></a>3.6 进程的Pagetable</h2><p>xv6采取的方式是内核有一个kernel pagetable，每一个进程有自己的process pagetable</p>
<blockquote>
<p>Having a separate page table for each process is necessary for <strong>process isolation</strong> as they should not be allowed to stomp on each others memory.</p>
</blockquote>
<p>每个进程都有自己的stack，如何检测到stcakoverflow呢？<br>我们注意到xv6每个stack之间都有guardian page，超出会访问guardian page造成page fault</p>
<blockquote>
<p>不同的进程可以使用相同的虚拟地址，但经过各自page table映射到不同的物理地址，彼此不会干扰。</p>
</blockquote>
<h2 id="3-7-Address-Space"><a href="#3-7-Address-Space" class="headerlink" title="3.7 Address Space"></a>3.7 Address Space</h2><blockquote>
<p>Like those other systems, upon a context switch, the user portion of the currently-running address space changes; the kernel portion is the same across processes.</p>
</blockquote>
<h2 id="3-8-问题"><a href="#3-8-问题" class="headerlink" title="3.8 问题"></a>3.8 问题</h2><ol>
<li>在加入新的文件之后，页表不能正确切换，有些已经建立的页表映射没有成功显示<br>最后定位到新加入文件bss段的一个变量，发现这个变量长度超过一个值就不能建立完整的页表映射，但是很说不通，最后发现linkerscript里面将根页表的起始地址和bss段重合了，在没加入这个新文件之前恰好没有影响到页表的建立。</li>
</ol>
<h1 id="4-进程-Process-线程-Thread"><a href="#4-进程-Process-线程-Thread" class="headerlink" title="4. 进程(Process) 线程(Thread)"></a>4. 进程(Process) 线程(Thread)</h1><h2 id="4-1-启动第一个进程"><a href="#4-1-启动第一个进程" class="headerlink" title="4.1 启动第一个进程"></a>4.1 启动第一个进程</h2><p>目前为止，内核的页表kernel pagetable已经设置好了，映射了整个DDR，即从0x80000000开始的128M地址空间。还映射了UART的位置0x10000000，大小为0x1000。trap的流程也走通了，m模式委托异常和中断给s模式，可以实现一些简单系统调用，例如打印等。但是我们其实现在仍然处于S模式，要知道用户程序肯定是在u模式当中运行的。接下来就应该从kernel启动一个init进程，而且这个init进程应该运行在u模式，并且这个用户程序可以通过系统调用或者中断的形式trap到s模式进行处理，处理之后还要返回到用户程序继续执行。</p>
<p>kernel pagetable配置的空间是kernel address space，用户进程需要的是process address space，进程不能够看到内核的代码，这需要设置一个新的进程页表。</p>
<p>而从kernel启动进程就需要我们提前设置user pagetable，随之而来的问题就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sfence.vma zero zero</span><br><span class="line">csrw satp a0</span><br><span class="line">sfence.vma zero zero</span><br></pre></td></tr></table></figure>

<p>执行完写satp寄存器之后，页表就会立刻更改，kernel space和process space如果没有把这段代码映射在相同的地方，执行就会出错cannot access</p>
<p>这就是trampoline代码的位置，xv6巧妙的利用了这段代码，从内核启动第一个用户进程不久相当于用户trap到内核，处理完成后再从内核退到用户进程吗？这一过程需要做几件事情才能完成进程的顺利启动：</p>
<ol>
<li>装载用户pagetable</li>
<li>保存当前kernel的context</li>
<li>装载用户程序的context</li>
</ol>
<p>完成上面的事情之后只需要一条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sret</span><br></pre></td></tr></table></figure>

<p>pc就会被硬件设置到sepc处，然后从pc开始运行。</p>
<p>接下来就完成一个init程序，这个程序只通过系统调用打印一个字符0。</p>
<p>参考xv6,发现有一段initcode[]是纯机器指令，这段initcode源码在xv6&#x2F;user下面，调用了一个syscall exec，运行了xv6的shell。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#反汇编initcode.out得到initcode[]</span></span><br><span class="line"><span class="comment">#小段存放</span></span><br><span class="line">riscv64-linux-gnu-objdump -d ./user/initcode.out</span><br></pre></td></tr></table></figure>

<p>效仿xv6的做法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">	li a7, 0x20</span><br><span class="line">	li a0, 0x30</span><br><span class="line">	ecall</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	j loop</span><br></pre></td></tr></table></figure>

<p>这里的系统调用号是0x20可能不符合规范，但是测试一下整个流程应该可以不用在意。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//U模式trap处理函数</span><br><span class="line">void user_trap()</span><br><span class="line">&#123;</span><br><span class="line">	int syscall_num = proc_list[0].trapframe-&gt;a7;</span><br><span class="line"></span><br><span class="line">	if(r_scause() == 8)</span><br><span class="line">	&#123;</span><br><span class="line">		//proc_list[0].trapframe-&gt;a0 = 8;</span><br><span class="line">		proc_list[0].trapframe-&gt;a0 = syscall[syscall_num]();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;user_trap(): unexpected scause %p \n&quot;, r_scause());</span><br><span class="line">		printf(fault_info[r_scause()-0x8000000000000000].fault_name);</span><br><span class="line">		panic(&quot;panic/n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proc_list[0].trapframe-&gt;epc = r_sepc() + 4;</span><br><span class="line">	user_trap_ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可见打印了一个0<br><img src="https://i.imgur.com/HeJ9s6n.png"></p>
<h2 id="4-2-进程之间的切换-scheduling"><a href="#4-2-进程之间的切换-scheduling" class="headerlink" title="4.2 进程之间的切换 scheduling"></a>4.2 进程之间的切换 scheduling</h2><p>xv6当中进程之间的切换不是从一个进程切换到新的进程，而是从一个进程切换到内核再从内核切换到新的进程。</p>
<p><img src="https://i.imgur.com/NhynPMJ.png"></p>
<p>xv6设置了定时器中断，当定时器中断到来时触发<strong>yield()<strong>，随后调用</strong>sched()<strong>，在</strong>sched()<strong>之中调用</strong>swtch()<strong>，</strong>swtch</strong>中的操作会使得cpu重新回到内核进程，而内核进程之前已经执行到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">       <span class="built_in">swtch</span>(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scheduler()</strong> 使用最简单的轮询算法完成新进程的选择，利用<strong>swtch()</strong> 进入新的进程。</p>
<p>第一个进程（打印0的那个进程）已经跑起来了，利用第一个进程把上述旧用户进程切换到内核scheduler进程，然后再切换到新内核进程的框架搭起来。相当于始终只调度一个用户进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切换到内核进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">back_to_kernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">swtch</span>(&amp;proc_ptr-&gt;context, &amp;kernel_ctxt.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//U模式trap处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user_trap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> syscall_num = proc_ptr-&gt;trapframe-&gt;a7;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> trap_cause = <span class="built_in">r_scause</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(trap_cause == <span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		proc_ptr-&gt;trapframe-&gt;a0 = syscall[syscall_num]();</span><br><span class="line">		proc_ptr-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>() + <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//S模式软件中断</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(trap_cause == <span class="number">0x8000000000000001</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;soft interrupt from s mode %p \n&quot;</span>, trap_cause);</span><br><span class="line">		<span class="built_in">w_sip</span>(<span class="built_in">r_sip</span>() &amp; ~<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">back_to_kernel</span>();</span><br><span class="line">		proc_ptr-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;user_trap(): unexpected scause %p \n&quot;</span>, trap_cause);</span><br><span class="line">		<span class="built_in">printf</span>(fault_info[<span class="built_in">r_scause</span>()].fault_name);</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;panic/n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">user_trap_ret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针<strong>proc_ptr</strong>始终指向当前运行的用户进程，<strong>kernel_ctxt</strong>是存储内核进程上下文的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内核进程一直在调度函数中循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> *nxt_proc_ptr = proc_ptr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> *kernel_ptr = &amp;kernel_ctxt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		proc_ptr = &amp;proc_list[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;MAX_PROC; n++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(proc_ptr-&gt;state == RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swtch</span>(&amp;kernel_ptr-&gt;context, &amp;proc_ptr-&gt;context);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proc_ptr++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scheduler()</strong> 遍历<strong>proc_list[MAX_PROC]<strong>，找到</strong>RUNNABLE</strong>的程序执行，目前我们只有<strong>initcode</strong>程序是<strong>RUNNABLE</strong>，存放在**proc_list[0]**。</p>
<p>编译后运行反复打印：<br><img src="https://i.imgur.com/wl3cr8p.png"></p>
<h2 id="4-3-创建新进程-fork"><a href="#4-3-创建新进程-fork" class="headerlink" title="4.3 创建新进程 fork()"></a>4.3 创建新进程 fork()</h2><p><strong>fork()</strong> 系统调用是接下来完成的函数，<strong>fork()</strong> 会将当前进程的全部内容复制一份，包括<strong>trapframe</strong>和代码</p>
<p>具体会做一些什么事情呢?</p>
<ol>
<li>查看进程数组，可分配的进程是有限的，是否还有可以分配的空位</li>
<li>分配<strong>pid</strong> 设置状态为<strong>USED</strong></li>
<li>分配<strong>pagetable</strong> <strong>trapframe</strong>的空间并映射</li>
<li>设置上下文如堆栈的位置</li>
<li>根据程序的长度来分配新的物理空间并用<strong>walk</strong>映射这些物理地址</li>
<li>设置状态为<strong>RUNNABLE</strong> 并返回<strong>PID</strong></li>
</ol>
<p>在看xv6源码时发现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br></pre></td></tr></table></figure>

<p><del>在fork()函数当中并没有为child process复制parent process的trapfram仅仅把child process的trapframe指针指向了parent的trapframe。这样不就会把parent的trapframe内容给修改了吗？</del></p>
<p>更改initcode代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">	li a7, 0x20 #系统调用号0x20 uart打印</span><br><span class="line">	li a0, 0x30 #0x30 ‘0’</span><br><span class="line">	ecall</span><br><span class="line"></span><br><span class="line">	li a7, 0x20</span><br><span class="line">	li a0, 0x31 #0x30 ‘1’</span><br><span class="line">	ecall</span><br><span class="line"></span><br><span class="line">	li a7, 0x01 #系统调用号0x01 fork()</span><br><span class="line">	ecall</span><br><span class="line"></span><br><span class="line">	li a7, 0x20</span><br><span class="line">	li a0, 0x32 #0x30 ‘2’</span><br><span class="line">	ecall</span><br><span class="line"></span><br><span class="line">	li a7, 0x20</span><br><span class="line">	li a0, 0x33 #0x30 ‘3’</span><br><span class="line">	ecall</span><br><span class="line">loop:</span><br><span class="line">	j loop</span><br></pre></td></tr></table></figure>

<p>如果代码运行正确：先通过系统调用打印出<strong>01</strong>，接着程序使用<strong>fork()</strong> 产生子进程，随后两个进程都会从14行开始执行，打印出<strong>2323</strong>或者<strong>2233</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *new_proc_ptr;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *proc_mem;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;MAX_PROC; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(proc_list[n].state == UNUSED)</span><br><span class="line">        &#123;</span><br><span class="line">            new_proc_ptr = &amp;proc_list[n];</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    found:</span><br><span class="line">    new_proc_ptr-&gt;pid = ++pid;</span><br><span class="line">    new_proc_ptr-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配pgt和trapframe的空间 并映射</span></span><br><span class="line">    new_proc_ptr-&gt;proc_pagetable = <span class="built_in">proc_pagetable</span>();</span><br><span class="line">    new_proc_ptr-&gt;trapframe = <span class="built_in">kalloc</span>();</span><br><span class="line">    <span class="built_in">map_page</span>(new_proc_ptr-&gt;proc_pagetable, (<span class="type">unsigned</span> <span class="type">long</span>)_trampoline, (<span class="type">unsigned</span> <span class="type">long</span>)TRAMPOLINE, <span class="number">1</span>, PTE_R | PTE_W | PTE_X);</span><br><span class="line">    <span class="built_in">map_page</span>(new_proc_ptr-&gt;proc_pagetable, new_proc_ptr-&gt;trapframe, <span class="number">0x3fffffe000</span>, <span class="number">1</span>, PTE_R|PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置返回的地址 第一次</span></span><br><span class="line">    new_proc_ptr-&gt;context.ra = fork_ret;</span><br><span class="line">    new_proc_ptr-&gt;context.sp = new_proc_ptr-&gt;kstack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制trapframe</span></span><br><span class="line">        *(new_proc_ptr-&gt;trapframe) = *(proc_ptr-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置子进程返回0</span></span><br><span class="line">    new_proc_ptr-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line">    new_proc_ptr-&gt;prog_size = proc_ptr-&gt;prog_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据程序的长度复制并映射</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;proc_ptr-&gt;prog_size; n+=<span class="number">4096</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pte = <span class="built_in">walk</span>(proc_ptr-&gt;proc_pagetable, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(*pte == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;pte == 0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pa = (<span class="type">unsigned</span> <span class="type">long</span>)(*pte)&gt;&gt;<span class="number">10</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">        proc_mem = <span class="built_in">kalloc</span>();</span><br><span class="line">        <span class="built_in">memmove</span>(proc_mem, pa, <span class="number">4096</span>);</span><br><span class="line">        <span class="built_in">map_page</span>(new_proc_ptr-&gt;proc_pagetable, proc_mem, n, <span class="number">1</span>, PTE_R|PTE_W|PTE_U|PTE_X);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置程序RUNNABLE</span></span><br><span class="line">    new_proc_ptr-&gt;state = RUNNABLE;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里部分内容有几个坑：<br><strong>1. undefined declaration of memcpy</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(new_proc_ptr-&gt;trapframe) = *(proc_ptr-&gt;trapframe);</span><br></pre></td></tr></table></figure>

<p>涉及到通过指针来复制结构体，尽管没有在代码中使用memcpy但是编译器会优化代码使用memcpy来完成复制，如果没有memcpy的声明就会出现undefined错误。</p>
<p><strong>2. 一直fork()直到用光proc_list[MAX_PROC]数组</strong><br><img src="https://i.imgur.com/melYd6o.png"><br>进入<strong>usertrap</strong>中断处理函数之后一定要先保存<strong>sepc</strong>寄存器的值，不然可能会被修改导致返回的地址不正确，出现多次fork()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//U模式trap处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user_trap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> syscall_num = proc_ptr-&gt;trapframe-&gt;a7;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> trap_cause = <span class="built_in">r_scause</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(trap_cause == <span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		proc_ptr-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>() + <span class="number">4</span>;</span><br><span class="line">		<span class="comment">//proc_list[0].trapframe-&gt;a0 = 8;</span></span><br><span class="line">		proc_ptr-&gt;trapframe-&gt;a0 = syscall[syscall_num]();</span><br><span class="line"><span class="comment">//		proc_ptr-&gt;trapframe-&gt;epc = r_sepc() + 4;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//S模式软件中断</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(trap_cause == <span class="number">0x8000000000000001</span>)</span><br><span class="line">	&#123;</span><br><span class="line">               proc_ptr-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">		<span class="comment">//printf(&quot;soft interrupt from s mode %p \n&quot;, trap_cause);</span></span><br><span class="line">		<span class="built_in">w_sip</span>(<span class="built_in">r_sip</span>() &amp; ~<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">back_to_kernel</span>();</span><br><span class="line"><span class="comment">//		proc_ptr-&gt;trapframe-&gt;epc = r_sepc();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;user_trap(): unexpected scause %p \n&quot;</span>, trap_cause);</span><br><span class="line">		<span class="built_in">printf</span>(fault_info[<span class="built_in">r_scause</span>()].fault_name);</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;panic/n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">user_trap_ret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. pid不对</strong><br>pid是一个全局变量初始化成0，但是后来发现变成了一个地址。查看map文件，问题最后定位到pid所在的位置和空闲内存的位置重叠，而空闲内存的管理使用的是最简单的链表，pid的位置正好是空闲内存存指针的地方。原本以为所有初始化之后的全局变量都在data段中存储，查看map文件后发现还有sbss段，里面存放的第一个变量就是pid。修改ld文件考虑sbss段。</p>
<p>什么时候在sbss段什么时候在data段，可能是要看编译器？</p>
<h2 id="4-4-进程睡眠-sleep"><a href="#4-4-进程睡眠-sleep" class="headerlink" title="4.4 进程睡眠 sleep()"></a>4.4 进程睡眠 sleep()</h2><p>进程会sleep，将当前进程状态设置为SLEEPING然后调用sched(),让当前进程主动放弃cpu</p>
<blockquote>
<p>The basic idea is to have sleep mark the current process as SLEEPING and then call sched to release the CPU;</p>
</blockquote>
<p>其实就是设置当前的进程是SLEEPING状态，SLEEPING状态的程序自然不能运行，所以我们切换到scheduler进程去重新选择一个进程执行。sched函数其实就是之前使用的backtokernel函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    proc_ptr-&gt;state = SLEEPING;</span><br><span class="line">    <span class="built_in">sched</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-进程的并发和同步"><a href="#4-1-进程的并发和同步" class="headerlink" title="4.1 进程的并发和同步"></a>4.1 进程的并发和同步</h2><p>以多线程计数器为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> share_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">routine</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        share_var++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>, routine, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>, routine, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, share_var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果大概率小于2000,在线程1没有将share_var+1的值写回到share_var时，可能线程2就被调度执行，此时线程2读取到的share_var仍然是0，加1后回写，share_var变成1,这时又轮到线程1执行，回写线程1的结果，最后share_var加了两次但是实际结果只加了一次，出现了数据更新的丢失。</p>
<p>需要注意的是即使将这条share_ptr++换成一条汇编的指令执行，仍然不能保证这个自加操作的原子性。即使这个程序在单个单核单线程CPU运行也不能保证原子性，因为CPU现在都是流水线执行，<strong>取指 译码 执行 访存 回写</strong>这五个阶段都可能会被打断，除非是单个单线程CPU在一个时钟周期可以完成五个阶段才能保证自加操作的原子性。</p>
<h2 id="4-2-spin-lock-自旋锁"><a href="#4-2-spin-lock-自旋锁" class="headerlink" title="4.2 spin lock (自旋锁)"></a>4.2 spin lock (自旋锁)</h2><blockquote>
<p>We cannot guarantee a thread execution order.</p>
</blockquote>
<p>就算有的线程新创建有的线程后创建，后创建的线程仍然有可能比先创建的线程先执行</p>
<p>竞争的产生 有一个共享变量，进程A去操作他的动作还没完成，进程B也去操作这个变量</p>
<p><strong>1. 关闭中断？</strong><br>进程的切换是通过定时器中断来完成的，在操作共享变量的时候关闭所有的中断可以避免进程的切换，这样就不会产生竞争<br>但是user space的程序可以有关闭中断的权利危险</p>
<p><strong>2. 使用一个lock变量？</strong><br>试想设置一个lock变量 如果lock&#x3D;0 表示没进程在访问 反之则有其他进程正在访问 进程A在访问共享变量之前 先测试lock的值<br>这样一来好像可以避免竞争 但是lock变量自己也是共享的 如果A进程得到lock&#x3D;0 在把lock赋值1之前 CPU切换到进程B 进程B也访问了lock 由于A还来得及上锁 B也认为可以操作共享内存<br>竞争再次发生</p>
<p><strong>3. spin lock</strong></p>
<p><strong>atomic operation</strong> (原子操作)<br>不可被打断的一串命令</p>
<p>TSL Test &amp; Set Lock</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将LOCK的值存入RX 并且设置LOCK=1</span><br><span class="line">TSL RX,LOCK</span><br></pre></td></tr></table></figure>

<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>trampoline.S又映射到了进程空间，又映射了内核空间，通过他的userret我们从kernel的S模式返回到了进程的U模式，当我们在进程的U模式时，有异常（系统调用）或者中断，我们通过uservec进入到内核S模式</p>
<h1 id="5-文件系统（FS）"><a href="#5-文件系统（FS）" class="headerlink" title="5. 文件系统（FS）"></a>5. 文件系统（FS）</h1><h2 id="5-1-virtio-disk"><a href="#5-1-virtio-disk" class="headerlink" title="5.1 virtio disk"></a>5.1 virtio disk</h2><p>运行在QEMU虚拟机上的xv6，其文件系统的读写是建立在virtio disk上面的，先完成virtio disk的驱动才能进行后面的操作。</p>
<h3 id="5-1-1-修改Makefile"><a href="#5-1-1-修改Makefile" class="headerlink" title="5.1.1 修改Makefile"></a>5.1.1 修改Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭legacy模式 legacy是之前的旧设备协议</span></span><br><span class="line">QEMU_OPTS = -global virtio-mmio.force-legacy=false</span><br><span class="line"><span class="comment">#磁盘镜像还没好先不指定</span></span><br><span class="line">QEMU_OPTS += -drive file=/dev/null,if=none,format=raw,id=x0</span><br><span class="line">QEMU_OPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加入刚才得设置</span></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    qemu-system-riscv64 <span class="variable">$(QEMU_FLAGS)</span> <span class="variable">$(QEMU_BIOS)</span> <span class="variable">$(QEMU_OPTS)</span> -kernel benos.elf</span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">    qemu-system-riscv64 <span class="variable">$(QEMU_FLAGS)</span> <span class="variable">$(QEMU_BIOS)</span> <span class="variable">$(QEMU_OPTS)</span> -kernel benos.elf -S -s</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-生成测试img文件"><a href="#5-1-2-生成测试img文件" class="headerlink" title="5.1.2 生成测试img文件"></a>5.1.2 生成测试img文件</h3><p>上面的配置只能测试磁盘得初始化不能测试读写，因为没有磁盘镜像。用dd工具生成一个随机得磁盘镜像来测试读写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#block size = 1024k</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=mydisk.img bs=1M count=10</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-virtio驱动"><a href="#5-1-3-virtio驱动" class="headerlink" title="5.1.3 virtio驱动"></a>5.1.3 virtio驱动</h3><h4 id="1-使能PLIC管理的磁盘中断"><a href="#1-使能PLIC管理的磁盘中断" class="headerlink" title="1. 使能PLIC管理的磁盘中断"></a>1. 使能PLIC管理的磁盘中断</h4><p>virtio disk的中断是由PLIC来控制的，PLIC由将这个中断传递给CPU，PLIC的中断信号对于CPU来说是外部中断，因此要使能S模式的外部中断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">w_sie</span>(<span class="built_in">r_sie</span>() | (<span class="number">0x01</span>&lt;&lt;<span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<h4 id="2-具体读写操作"><a href="#2-具体读写操作" class="headerlink" title="2. 具体读写操作"></a>2. 具体读写操作</h4><p>virtio disk读写都要通过struct buf结构体来完成，buf结构体的dev成员设置0x01</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">buf</span> &#123;</span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="comment">//struct sleeplock lock;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *prev; <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *next;</span><br><span class="line">  uchar data[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试virtio_disk_rw，向第0个block写1024个byte，内容都是0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">buf</span> *test_buf = (<span class="keyword">struct</span> buf *)<span class="built_in">kalloc</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(test_buf, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line">test_buf-&gt;dev = <span class="number">0x1</span>;</span><br><span class="line">test_buf-&gt;blockno = <span class="number">0</span>;</span><br><span class="line">test_buf-&gt;valid = <span class="number">0</span>;</span><br><span class="line">test_buf-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">virtio_disk_rw</span>(test_buf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在内核当中直接测试的时候一定要主要这个<strong>test_buf</strong>分配空间别放在<strong>free_mem</strong>之前了，不然后面的设置就全都没用了。</p>
<p>用<strong>hexdump</strong>查看写测试之前的磁盘内容，一行是16bytes，从0x0000开始：</p>
<p><img src="https://i.imgur.com/WeIaEUv.png"></p>
<p>运行程序写一个block之后,第一个block已经成功变成0</p>
<p><img src="https://i.imgur.com/zHz5zAD.png"></p>
<p>读写失败的情况：在gdb中可以查看test_buf具体的值，dev成员的值不对，block的值也不对，可能是由于test_buf有些成员没有设置正确，返回的data数组的值也是任意的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /x *test_buf</span><br><span class="line">$<span class="number">1</span> = &#123;valid = <span class="number">0x0</span>, disk = <span class="number">0x0</span>, dev = <span class="number">0x1000</span>, blockno = <span class="number">0x3</span>, refcnt = <span class="number">0x1</span>, pre = <span class="number">0x0</span>, nxt = <span class="number">0x0</span>, data = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">129</span> times&gt;, <span class="number">0xf0</span>,</span><br><span class="line">    <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">156</span> times&gt;, <span class="number">0xd0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">156</span> times&gt;, <span class="number">0xb0</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2</span>,</span><br><span class="line">    <span class="number">0x0</span> &lt;repeats <span class="number">156</span> times&gt;, <span class="number">0x90</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">156</span> times&gt;, <span class="number">0x70</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">156</span> times&gt;, <span class="number">0x50</span>, <span class="number">0xff</span>,</span><br><span class="line">    <span class="number">0xff</span>, <span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">91</span> times&gt;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FAT（File-Allocation-Table）"><a href="#FAT（File-Allocation-Table）" class="headerlink" title="FAT（File Allocation Table）"></a>FAT（File Allocation Table）</h2><p>用链表把一个一个block链接起来，链表是集中存放并且有多个备份</p>
<h2 id="5-2-基于Inode的文件系统"><a href="#5-2-基于Inode的文件系统" class="headerlink" title="5.2 基于Inode的文件系统"></a>5.2 基于Inode的文件系统</h2><p>inode会在磁盘和RAM当中各一份，RAM当中我们直接写作inode，磁盘当中我们写作dinode作为区分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总大小64bytes</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dinode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用major来指定是哪种设备 minor来指定是这种设备的哪一个</span></span><br><span class="line">    <span class="type">short</span> major;</span><br><span class="line">    <span class="type">short</span> minor;</span><br><span class="line">    <span class="comment">//三种type：file device directory</span></span><br><span class="line">    <span class="type">short</span> type;</span><br><span class="line">    <span class="type">short</span> nlink;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//12个直接块 1个间接块</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block_addr[NDIRECT+NINDIRECT];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>xv6当中定义NINDIRECT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT BSIZE/(sizeof(unsigned int))</span></span><br></pre></td></tr></table></figure>

<p>虽然dinode只用了一个指针来指向<strong>indirect block</strong>，但是一个间接块当中其实含有<strong>Block_Size&#x2F;sizeof(指针长度)</strong> 个指向block的指针。</p>
<p><img src="https://i.imgur.com/DCh5WeF.png" alt="dinode 结构体"></p>
<p>inode是从dinode读取填入的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dev_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inode_num;</span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">int</span> ref;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dinode</span> inode_copy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Directory Entry 目录项</strong><br>如果没有目录，那么所有的文件都是平行的。目录是一种特殊的文件，一级目录就可以理解成一个文件夹。我们每创建一个文件就会分配一个inode，每创建一个文件夹也会分配inode，文件的数据块存放的是文件的内容，目录的数据块存放的是当前文件夹下面文件和子文件夹的dirtectory entry用struct dirent表示。所以每新添加一个文件需要朝他所在的文件夹的数据块添加他的dirent</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小16bytes</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> &#123;</span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-1-创建文件系统到磁盘主要API"><a href="#5-2-1-创建文件系统到磁盘主要API" class="headerlink" title="5.2.1 创建文件系统到磁盘主要API"></a>5.2.1 创建文件系统到磁盘主要API</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小端转换</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">xshort</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">xint</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据block号 读写缓冲buf内容来写</span></span><br><span class="line"><span class="built_in">wr_block</span>(<span class="type">unsigned</span> <span class="type">int</span> n_block, <span class="type">void</span> *buf);</span><br><span class="line"><span class="built_in">rd_block</span>(<span class="type">unsigned</span> <span class="type">int</span> n_block, <span class="type">void</span> *buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写磁盘里面的inode</span></span><br><span class="line"><span class="built_in">wr_inode</span>(<span class="type">unsigned</span> <span class="type">int</span> inum, <span class="keyword">struct</span> dinode *new_dinode);</span><br><span class="line"><span class="built_in">rd_inode</span>(<span class="type">unsigned</span> <span class="type">int</span> inum, <span class="keyword">struct</span> dinode *new_dinode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配新的inode 并写入inode blk</span></span><br><span class="line"><span class="comment">//注意！！！ inode结构体在使用之前一定要先将里面的东西全部清零</span></span><br><span class="line"><span class="built_in">inode_alloc</span>(<span class="type">unsigned</span> <span class="type">short</span> file_type);</span><br><span class="line"></span><br><span class="line"><span class="comment">//inode增加内容</span></span><br><span class="line"><span class="built_in">inode_append</span>(<span class="type">unsigned</span> <span class="type">int</span> inum, <span class="type">void</span> *buf, <span class="type">int</span> n);</span><br></pre></td></tr></table></figure>

<p>大小端转换如果本来就是小端了那么使用xint函数输入等于输出。xv6使用了这个转换应该主要是考虑到会用在大端的磁盘上面。</p>
<p>实现一个最基本的文件系统结构，先不要log块</p>
<table>
<thead>
<tr>
<th align="center">分区</th>
<th align="center">boot</th>
<th align="center">superblock</th>
<th align="center">inode block</th>
<th align="center">bitmap block</th>
<th align="center">data blocks</th>
</tr>
</thead>
<tbody><tr>
<td align="center">块号</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4及之后</td>
</tr>
<tr>
<td align="center">起始地址</td>
<td align="center">0x00</td>
<td align="center">0x400</td>
<td align="center">0x800</td>
<td align="center">0xc00</td>
<td align="center">0x1000</td>
</tr>
</tbody></table>
<p>里面比较费劲的实现应该就是<strong>inode_append</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//往对应inode文件添加内容</span></span><br><span class="line"><span class="comment">//*xinput对应待添加数据的首地址</span></span><br><span class="line"><span class="comment">//n对应数据长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inode_append</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> inum, <span class="type">void</span> *input, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p = (<span class="type">char</span> *)input;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> <span class="title">dinode_buf</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, fbn, actual_wr_len;</span><br><span class="line">	<span class="type">char</span> indirect[BSIZE / <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> blk_num;</span><br><span class="line">	<span class="type">char</span> data_buf[BSIZE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取inode到buf里面</span></span><br><span class="line">	rd_inode(inum, &amp;dinode_buf);</span><br><span class="line"></span><br><span class="line">	offset = xint(dinode_buf.size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;offset = 0x%x\n&quot;</span>, offset);</span><br><span class="line">	<span class="comment">//循环条件 如果添加的内容还没有添加完</span></span><br><span class="line">	<span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;length = 0x%x\n&quot;</span>, len);</span><br><span class="line">		<span class="comment">//完整块的数量</span></span><br><span class="line">		fbn = offset / BSIZE;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fbn = %u\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果这个文件数据块的数量小于直接块的数量</span></span><br><span class="line">		<span class="keyword">if</span>(fbn &lt; NDIRECT)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//对应还没有分配的情况 或者刚刚好文件大小是BSIZE的整数倍</span></span><br><span class="line">			<span class="keyword">if</span>(xint(dinode_buf.data_address[fbn] == <span class="number">0</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				dinode_buf.data_address[fbn] = xint(freeblock++);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			blk_num = xint(dinode_buf.data_address[fbn]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果超过了直接快</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//看看间接块的地址有没有分配</span></span><br><span class="line">			<span class="keyword">if</span>(xint(dinode_buf.data_address[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dinode_buf.data_address[NDIRECT] = freeblock++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//读取间接块</span></span><br><span class="line">			rd_sec(dinode_buf.data_address[NDIRECT], (<span class="type">char</span> *)indirect);</span><br><span class="line">			<span class="comment">//查看有没有分配</span></span><br><span class="line">			<span class="keyword">if</span>(indirect[fbn-NDIRECT] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				indirect[fbn-NDIRECT] = freeblock++;</span><br><span class="line">                <span class="comment">//分配之后将数据写回去</span></span><br><span class="line">				wr_sec(dinode_buf.data_address[NDIRECT], (<span class="type">char</span> *)indirect);</span><br><span class="line">			&#125;</span><br><span class="line">			blk_num = indirect[fbn-NDIRECT];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取这一块的内容到缓存</span></span><br><span class="line">		rd_sec(blk_num, data_buf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//等待添加的内容可能比当前块剩余的空间少或者多</span></span><br><span class="line">		<span class="comment">//我们只写入最少的</span></span><br><span class="line">		<span class="comment">//如果直接按照剩余空间长度来写 可能会造成segment fault</span></span><br><span class="line">		actual_wr_len = min(n, (fbn+<span class="number">1</span>)*BSIZE-offset);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;actual_wr_len = %d\n&quot;</span>, actual_wr_len);</span><br><span class="line">		<span class="built_in">memcpy</span>(data_buf+offset-(fbn*BSIZE), p, actual_wr_len);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//回写</span></span><br><span class="line">		wr_sec(blk_num, data_buf);</span><br><span class="line"></span><br><span class="line">		len -= actual_wr_len;</span><br><span class="line">		offset += actual_wr_len;</span><br><span class="line">		p += actual_wr_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dinode_buf.size = offset;</span><br><span class="line">	wr_inode(inum, &amp;dinode_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示<br>第0块 <strong>[0x3ff:0x00]</strong> 是boot 没有内容<br>第1块 <strong>[0x7ff:0x400]</strong> 是sb 起始内容是设置的magic number<br>第2块 <strong>[0xaff:0x800]</strong> 是inode块 每条inode长64byte对应四行的长度 从第12byte开始就是对应的direct block的块号<br>第3块 <strong>[0xfff:0xc00]</strong> 是bitmap 没有填写<br>第4块 <strong>[0x13ff:0x1000]</strong> 是数据块 创建rootdir时将这块分配给他作为datablock 用于存放rootdir文件夹下的子文件和子文件夹</p>
<p>rootdir是第一个创建的文件类型是文件夹 分配的数据块号是4对应 <strong>[0x13ff:0x1000]</strong> 后来又添加了两个文件 这两个文件属于rootdir 因此会创建相应的directory entry到4号数据块</p>
<p><img src="https://i.imgur.com/L88wFbv.png" alt="测试图"><br><img src="https://i.imgur.com/oPT8bHO.png" alt="测试图"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用read_sb读取superblock的内容时，最开始偷懒直接用函数当中的临时变量struct buf结构体来存储virtio返回的数据块，在初始化的时候没问题，但是放在fork_ret当中去执行总是读取的不对，data里面全部是空。换成heap上分配的内存来存储就没问题，栈空间不够？但是gdb查看时发现是够用的，暂时还不知道为什么。</p>
<h2 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec()系统调用"></a>exec()系统调用</h2><p>exec()和文件系统的实现密切相关，本来在fork()系统调用之后接着就实现exec()系统调用，但是在查看了xv6的源码之后发现没有文件系统还真写不出来。exec()的任务很简单：</p>
<blockquote>
<p>exec is a system call that replaces a process’s user address space with data read from a file, called a binary or executable file.</p>
</blockquote>
<p>exec()执行新的程序，他的方式就是把当前进程的一切替换成将要执行的程序的内容。</p>
<table>
<thead>
<tr>
<th align="center">elf文件组成</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>elf header</strong></td>
</tr>
<tr>
<td align="center"><strong>program header</strong></td>
</tr>
<tr>
<td align="center">…</td>
</tr>
<tr>
<td align="center">.init</td>
</tr>
<tr>
<td align="center">.plt</td>
</tr>
<tr>
<td align="center">.text</td>
</tr>
<tr>
<td align="center">.rodata</td>
</tr>
<tr>
<td align="center">.data</td>
</tr>
<tr>
<td align="center">.bss</td>
</tr>
<tr>
<td align="center">.comment</td>
</tr>
<tr>
<td align="center">.symtab</td>
</tr>
<tr>
<td align="center">…</td>
</tr>
<tr>
<td align="center"><strong>section header</strong></td>
</tr>
</tbody></table>
<ol>
<li>通过path字符串找到这个文件的inode，inode包含了这个文件的所有信息</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">get_nxt_name</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_inode</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> inode *ino)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据inode提供的信息解析elf header的内容</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">//必须是0x7f+ELF</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];     <span class="comment">//</span></span><br><span class="line">  ushort type;       <span class="comment">//文件类型</span></span><br><span class="line">                     <span class="comment">//可重定位文件（Relocatable File）</span></span><br><span class="line">                     <span class="comment">//可执行文件（Executable File）</span></span><br><span class="line">                     <span class="comment">//共享目标文件（Shared Object File）等几种类型</span></span><br><span class="line">  ushort machine;    <span class="comment">//架构 riscv对应243</span></span><br><span class="line">  uint version;</span><br><span class="line">  uint64 entry;      <span class="comment">//程序入口</span></span><br><span class="line">  uint64 phoff;      <span class="comment">//Program Header Table 在文件中的偏移量</span></span><br><span class="line">  uint64 shoff;      <span class="comment">//Section Header Table 在文件中的偏移量</span></span><br><span class="line">  uint flags;        <span class="comment">//标志位，表示与文件相关的处理器标志</span></span><br><span class="line">  ushort ehsize;     <span class="comment">//ELF Header大小 通常是 52 字节。</span></span><br><span class="line">  ushort phentsize;  <span class="comment">//Program Header Table 中每个表项的大小。</span></span><br><span class="line">  ushort phnum;      <span class="comment">//Program Header Table 中表项的数量</span></span><br><span class="line">  ushort shentsize;  <span class="comment">//Section Header Table 中每个表项的大小。</span></span><br><span class="line">  ushort shnum;      <span class="comment">//Section Header Table 中表项的数量</span></span><br><span class="line">  ushort shstrndx;   <span class="comment">//包含节名称的字符串表在 Section Header Table 中的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<strong>readelf</strong>工具可以帮助我们分析写入的elf文件</p>
<ol start="3">
<li>根据elf header分配pgt 填充程序各段的位置</li>
</ol>
<p>在完成elf文件程序装载时又发现：因为之前都是很短的程序所以我们分配的都是一个页就行了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//分配新的页表</span></span><br><span class="line">    <span class="type">pgt_t</span> user_pagetable = proc_pagetable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//映射trampoline</span></span><br><span class="line">    <span class="comment">//映射trapframe</span></span><br><span class="line">    <span class="comment">//映射stack</span></span><br><span class="line">    map_page(user_pagetable, (<span class="type">unsigned</span> <span class="type">long</span>)_trampoline, (<span class="type">unsigned</span> <span class="type">long</span>)TRAMPOLINE, <span class="number">1</span>, PTE_R | PTE_X);</span><br><span class="line">    map_page(user_pagetable, (<span class="type">unsigned</span> <span class="type">long</span>)proc_ptr-&gt;trapframe, (<span class="type">unsigned</span> <span class="type">long</span>)TRAMPOLINE<span class="number">-0x1000</span>, <span class="number">1</span>, PTE_R | PTE_W);</span><br><span class="line">    map_page(user_pagetable, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">stack</span>, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="number">4096</span>, <span class="number">1</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取elfhdr proghdr</span></span><br><span class="line">    <span class="comment">//分配装载程序内容的物理地址并映射</span></span><br><span class="line">    <span class="comment">//装载程序内容到刚才分配的物理地址</span></span><br><span class="line">    read_elfhr(&amp;proc_elfhdr, &amp;proc_proghdr, &amp;proc_inode);</span><br><span class="line">    uvmalloc(user_pagetable, <span class="number">0</span>, proc_proghdr.memsz, <span class="number">0</span>);</span><br><span class="line">    loadsec(user_pagetable, &amp;proc_inode, proc_proghdr.vaddr, proc_proghdr.off, proc_proghdr.filesz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填写程序结构体</span></span><br><span class="line">    proc_ptr-&gt;proc_pagetable = user_pagetable;</span><br><span class="line">    proc_ptr-&gt;prog_size = <span class="number">4096</span>;</span><br><span class="line">    proc_ptr-&gt;trapframe-&gt;epc = proc_elfhdr.entry;</span><br><span class="line">    proc_ptr-&gt;trapframe-&gt;sp = <span class="number">4096</span>+<span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试exec-系统调用"><a href="#测试exec-系统调用" class="headerlink" title="测试exec()系统调用"></a>测试exec()系统调用</h3><p>在第一个用户程序initcode当中调用exec</p>
<h2 id="5-3-File-Descriptor-Layer"><a href="#5-3-File-Descriptor-Layer" class="headerlink" title="5.3 File Descriptor Layer"></a>5.3 File Descriptor Layer</h2><p>在完成inode层之后本想紧接着实现一系列和文件相关的系统调用如**pipe()**，却发现在inode之上都还有一层。先来看看在完成inode之后我们得到了什么？我们可以以文件路径的方式访问存储在img文件中的任何一个文件或者文件夹，但是这离把所有的资源都抽象成文件还不够。</p>
<p>我们还需要一层<strong>File Descriptor Layer</strong>：</p>
<p><img src="https://hackmd.io/_uploads/ryTx1cXV2.png"></p>
<p>xv6用<strong>struct file</strong>结构体实现了所有资源都是文件的统一,<strong>struct file</strong>就是对<strong>inode</strong>和<strong>pipe</strong>的一个新的封装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE I/O offset</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://academy.cba.mit.edu/classes/networking_communications/SD/FAT.pdf">FAT</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.williams.edu/~cs432/labs/07-files.pdf">07-files.pdf</a></p>
<h1 id="6-开启多核"><a href="#6-开启多核" class="headerlink" title="6. 开启多核"></a>6. 开启多核</h1><p>走到这里发现很多的系统调用和函数都涉及到锁，还是开启多核把最基本的并发同步实验做了吧。</p>
<p>QEMU开启多核添加</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="为printf-加锁"><a href="#为printf-加锁" class="headerlink" title="为printf()加锁"></a>为printf()加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xv6使用的是gcc编译器生成的命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反汇编之后可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0000000080201fa4 &lt;acquire&gt;:</span><br><span class="line">    80201fa4:   fe010113            addi    sp,sp,-32     80201fa8:   00813c23            sd  s0,24(sp)</span><br><span class="line">    80201fac:   02010413            addi    s0,sp,32</span><br><span class="line">    80201fb0:   fea43423            sd  a0,-24(s0)</span><br><span class="line">    80201fb4:   00000013            nop</span><br><span class="line">    80201fb8:   fe843783            ld  a5,-24(s0)</span><br><span class="line">    80201fbc:   00100713            li  a4,1</span><br><span class="line">    80201fc0:   0ce7a72f            amoswap.w.aq    a4,a4,(a5)</span><br><span class="line">    80201fc4:   0007079b            sext.w  a5,a4</span><br><span class="line">    80201fc8:   fe0798e3            bnez    a5,80201fb8 &lt;acquire+0x14&gt;</span><br><span class="line">    80201fcc:   0ff0000f            fence</span><br><span class="line">    80201fd0:   00000013            nop</span><br><span class="line">    80201fd4:   01813403            ld  s0,24(sp)</span><br><span class="line">    80201fd8:   02010113            addi    sp,sp,32</span><br><span class="line">    80201fdc:   00008067            ret</span><br></pre></td></tr></table></figure>

<p>栈帧基本上是16byte的倍数 前2个byte是ra和s0(fp),后面放参数</p>
<ul>
<li><input disabled="" type="checkbox"> [] semaphore信号量</li>
<li><input disabled="" type="checkbox"> sleep wakeup实现等待队列</li>
</ul>
<h2 id="sleep-wakeup-同步机制"><a href="#sleep-wakeup-同步机制" class="headerlink" title="sleep() wakeup()同步机制"></a>sleep() wakeup()同步机制</h2><ul>
<li><input disabled="" type="checkbox"> todo</li>
<li><input disabled="" type="checkbox"> 对比linux</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">	    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">	    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">	    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">	      <span class="string">&quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>uboot启动传参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *r2 DTB表的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kernel_entry(<span class="number">0</span>, machid, r2);</span><br></pre></td></tr></table></figure>



<p>uboot为什么从0x20000开始：DOS时代使用1M一下的内存</p>
<p>uboot跳到head.S</p>
<h1 id="7-内存管理"><a href="#7-内存管理" class="headerlink" title="7. 内存管理"></a>7. 内存管理</h1><h2 id="1-操作系统为什么需要能够连续的物理页？"><a href="#1-操作系统为什么需要能够连续的物理页？" class="headerlink" title="1. 操作系统为什么需要能够连续的物理页？"></a>1. 操作系统为什么需要能够连续的物理页？</h2><p>有了虚拟空间之后似乎好像不再依赖连续的地址空间了，但是从linux使用的buddy allocator来看，操作系统仍然需要经常分配连续的物理地址。</p>
<ol>
<li>某些硬件设备（如DMA控制器）可能要求连续的物理页来进行数据传输。磁盘大文件传输。</li>
<li>尽管虚拟内存可以将物理内存映射到不连续的虚拟地址空间，但在某些情况下，连续的物理页可以带来性能上的优势。例如，连续的物理页可以提高缓存的命中率，减少内存访问的延迟。</li>
</ol>
<p>之前实现的物理内存分配中只有一个单位–<strong>页</strong>，但是很明显我们还需要一种小内存的分配管理办法，不然这个内存分配的内部碎片就太大了，哪怕我们只需要malloc(1)也会分配4K的空间。</p>
<ul>
<li><input disabled="" type="checkbox"> 完善内存管理</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">virt board</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv">xv6_riscv</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/runninglinuxkernel/riscv_programming_practice">RV体系结构编程与实践</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/plctlab/riscv-operating-system-mooc">riscv-operating-system-mooc</a></p>
<p><a target="_blank" rel="noopener" href="https://ipads.se.sjtu.edu.cn/ospi/">操作系统：原理与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://libgen.is/book/index.php?md5=F6FE9D77E7CC5647FE35B0446F34B5AC">Operating Systems Design and Implementation</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB">hhp3</a></p>
<p><a target="_blank" rel="noopener" href="http://web.cs.ucla.edu/classes/winter12/cs111/scribe/15e/#:~:text=Having%20a%20separate%20page%20table,will%20work%20for%20every%20process.">Virtual Memory</a></p>
<p><a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2022/">南大操作系统课</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PL2Yggtk_pK6-R9ehjj0AoTnWrNOLChuld">CS134</a></p>
<p><a target="_blank" rel="noopener" href="https://notnik.cc/posts/async/">coroutine</a></p>
<p><a target="_blank" rel="noopener" href="https://brennan.io/2020/03/22/sos-block-device/">virtio driver</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://songyj123.github.io/2023/05/25/rvos/" data-id="cli3787120000spp8b2th2csk" data-title="rvos" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/risc-v-os/" rel="tag">risc-v os</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/05/25/test2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">test2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/risc-v-os/" rel="tag">risc-v os</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/risc-v-os/" style="font-size: 10px;">risc-v os</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/25/rvos/">rvos</a>
          </li>
        
          <li>
            <a href="/2023/05/25/test2/">test2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 SONGyj<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>